---
title: Webpack八股
date: 2023/9/16
type: tech
---

# Webpack

## 解决的问题

在过去，开发者要进行模块化开发，会通过约定每个JS文件为一个独立的模块，但这种方式存在全局污染、难以维护、模块与模块之间并不存在依赖的问题。然后就出现用立即执行函数的形式来去维护每个JS文件的私有空间，将模块的内容挂载到一个全局对象中，只向外暴露这一个对象。但仍然没有解决代码难以维护的问题（模块依赖不明确，需要手动确认模块加载顺序；模块之间通过全局对象通信，耦合性较高）。

随着JS在服务端的应用逐渐增多，人们意识到模块化的重要性，所以后来提出了 **CJS** 作为Node环境中的模块化规范。但在浏览器环境下并不能够很好地支持 CJS ，主要是由于 CJS 是同步加载模块。这在服务端环境是可行的，因为资源都在本地。但在浏览器环境下就会因为请求服务端中的模块导致阻塞任务执行，必须等待模块加载完成才能执行后续的任务，从而导致页面出现卡顿等性能问题，极大影响用户体验。

但后来又出现了 **AMD**（异步模块定义）和 **UMD**（通用模块定义）来支持浏览器端的模块化。

AMD 与 UMD 的区别在于 AMD 是<u>依赖前置、提前执行</u>，而 UMD 是<u>依赖就近、延迟执行</u>。

**依赖前置、提前执行**指的是依赖推荐写在代码的开始位置，依赖会在模块执行之前被加载，同时依赖在加载完成后会立即执行，所有依赖加载完后才再执行当前模块的代码。

**依赖就近、延迟执行**指的是依赖可以在需要时才进行导入，加载完依赖后并不会立即执行，而是先执行当前模块的代码，等执行到导入依赖的语句时才执行对应的依赖。

Webpack的出现也使得 CJS 可以在浏览器端支持，同时Webpack也提供了其他强大的功能，比如模块整合、代码压缩、模块分割、热更新提高开发效率等。

## 打包流程

1. **初始化**：Webpack先加载配置文件的配置项，然后创建一个编译器实例。
2. **编译**：初始化完成之后，则开始进行Webpack的编译构建流程。从配置文件中指定的入口文件出发，递归地解析模块之间的依赖关系。在这个过程中，Webpack会使用配置的**loader**对相应的模块进行转换，将其转换为Webpack能够处理资源。同时，生成对应的抽象语法树（**AST**）。通过遍历抽象语法树进行模块的依赖收集，根据依赖关系和配置文件中的规则，将模块分割成不同的**chunk**（入口chunk、异步加载的chunk或公共的chunk），Webpack还会应用各种优化策略，比如代码压缩、去除未使用代码、提取公共模块等。
3. **输出**：将处理好的chunk转换为静态资源文件，并根据配置文件输出到指定目录下。